# -*- coding: utf-8 -*-
"""
Created on Tue Dec 10 09:31:55 2019

@author: WILLIAMCLAY
"""

import argparse

import numpy as np
import matplotlib.pyplot as plt
import math
from timeit import default_timer as timer
import numba
from scipy import spatial
from matplotlib import pyplot as plt
from PIL import Image as im
from tifffile_local import imwrite
import csv

# import mufit_analysis_nd as mufit
# import picasso_utils as picasso


class simMovie(list):
    def __init__(self,dtype):
        self.dtype = dtype

def _testsim(args):
    
    NA = 1.33
    
    print("test sim....")

    print("test sim.....")
    prefix = "testsim_px_{}_N_{}_b_{}_fr_{}_it_{}_gs_{}_bg_{}".format(args.pixels,args.N,args.box_side_length,args.frames,args.integration_time,args.grid_size,args.background)
    cw = csv.writer(open(prefix+'_points.csv','w',newline=''),delimiter=',')
    movie = simMovie(np.dtype("u2"))
    
    pointList = []
    simLists = randomMovieList(args)
    for i in range(args.frames):
        #Nf = _np.random.poisson(args.N)
        
        #simList = PAINT_sim.randomFluorList(Nf,args.box_side_length)
        for id in range(len(simLists[i])):
            point = simLists[i][id]
            pointList.append([point[0],point[1]])
            
        #bg = args.background
        image1 = simulatePaintImage(simLists[i],args)
        
        #_np.array(simList).tofile("points.csv",sep=",")
        
        movie.append(image1)
        for item in simLists[i]:
            cw.writerow([i]+list(item));
        
        #image2 = PAINT_sim.simulatePaintImage(PAINT_sim.randomFluorList(4000,args.box_side_length))
        if i%10 == 0:
            print("test sim...... frame",i)
        
        #plt.imshow(image1)
        #plt.show()
        
        #imFile = im.fromarray(image1,"F")
        
        #imFile.save("test.tiff")
        
    imwrite(prefix+".tiff",np.array(movie[:],dtype=movie.dtype))
    '''
    # mufit.analyze(prefix+".tiff",prefix+".hdf5",args.xml)
    
    locs,info = picasso.load_salocs(prefix+".hdf5")
    
    picasso.save_locs(prefix+"_locs.hdf5",locs,info)

    pointList = np.array(pointList)
    
    LOCS_DTYPE = [
                ("frame", "u4"),
                ("x", "f4"),
                ("y", "f4"),
                ("photons", "f4"),
                ("sx", "f4"),
                ("sy", "f4"),
                ("bg", "f4"),
                ("lpx", "f4"),
                ("lpy", "f4"),
            ]
    
    nPoints = pointList.shape[0];
    
    frame = np.zeros((nPoints,),dtype="u4")
    x = np.zeros((nPoints,))
    y = np.zeros((nPoints,))
    photons = np.zeros((nPoints,))
    sx = np.zeros((nPoints,))
    sy = np.zeros((nPoints,))
    bg = np.zeros((nPoints,))
    lpx = np.zeros((nPoints,))
    lpy = np.zeros((nPoints,))
    
    ptIdx = 0
    
    effP = args.pixel_size/args.magnification
    
    for i in range(args.frames):
        for id,point in enumerate(simLists[i]):
            frame[ptIdx] = i
            x[ptIdx] = point[1]/effP
            y[ptIdx] = point[0]/effP
            photons[ptIdx] = point[3]
            sx[ptIdx] = 0.45*point[2]/1000/2/NA/effP
            sy[ptIdx] = sx[ptIdx]
            bg[ptIdx] = args.background
            lpx[ptIdx] = np.sqrt((sx[ptIdx]**2+1/12)/photons[ptIdx]+8*np.pi*sx[ptIdx]**4*bg[ptIdx]/photons[ptIdx]**2)
            lpy[ptIdx] = lpx[ptIdx]
            ptIdx+=1
            
            
    img_info = {}
    img_info["Generated by"] = "testsim.py"
    img_info["Frames"] = int(np.max(frame)) + 1
    img_info["Height"] = int(np.ceil(np.max(y)))
    img_info["Width"] = int(np.ceil(np.max(x)))

    gtInfo = []
    gtInfo.append(img_info)   
        
    gtLocs = np.rec.array((frame,x,y,photons,sx,sy,bg,lpx,lpy),dtype = LOCS_DTYPE)
    picasso.save_locs(prefix+"_gtlocs.hdf5",gtLocs,gtInfo)
    
    '''
    #return locs,gtLocs
    
# =============================================================================
#     movie[:] = [image1]
#     identifications = localize.identify(movie,args.gradient,args.box_side_length,False)
#     print("test sim.......")
#     print(identifications.shape)
#     camera_info = {}
#     camera_info["baseline"] = args.baseline
#     camera_info["sensitivity"] = args.sensitivity
#     camera_info["gain"] = args.gain
#     camera_info["qe"] = args.qe
#     fitResults = localize.fit(movie,camera_info,identifications,args.box_side_length)
#     print(fitResults.shape)
#     #print(fitResults)
#     
#     Nl = fitResults.shape[0]
#     locList = np.zeros((Nl,2));
#     for id in range(Nl):
#         point = fitResults[id]
#         locList[id,:] = [point[2],point[1]]
#         
#     nnTree = spatial.cKDTree(pointList/16*150)
#     nn = nnTree.query(locList)
#     #print(pointList.shape)
#     #print(pointList/.1066667)
#     #print(locList.shape)
#     #print(locList)
#     #print(nn[0]*1000*.1066667)
#     count =0;
#     for item in nn[0]:
#         if item*1000*.106667 < 5:
#             count+=1
#     print(count)
# =============================================================================
    
def randIndex(cumProbabilities): 
    """find random item from cumulative summed probabilites np.array"""
    prob = cumProbabilities
    
    start = 0
    end = len(prob)-1
    
    rand = np.random.rand()*prob[end];
    #print(rand)
    
    while end-start > 0:
        middle = int                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ((end+start)/2);
        if prob[middle] > rand:
            end = middle
        else:
            start = middle+1
    
    return end

@numba.jit(nopython=True)
def readBit(byteArray,n):
    nnBit = 8*len(byteArray)
    if n >= nnBit:
        return 0
    byteId = int(n/8)
    return (byteArray[byteId] >> (n % 8)) % 2

@numba.jit(nopython = True)
def randomPixelList(image,N):
    image = np.array(image)
    if len(image.shape) > 2: 
        image = np.sum(image,2)/image.shape[2]
        
    imProb = image.flatten()
    imProb = np.cumsum(imProb)
    pixelList = []
    start = timer()
    
    for index in range(N):
        #kk = randIndex(imProb)
        kk = imProb.searchsorted(np.random.rand()*imProb[-1])
        row = math.floor(kk/image.shape[1])
        col = kk%image.shape[1]
        #row = imageRowCumSums.searchsorted(np.random.rand())
        #col = imageColCumSums[row,:].searchsorted(np.random.rand())
        pixelList.append((row,col))
        
    end = timer()
    print(end-start)
        
    
    return pixelList

def randomFluorList(N,randData,args):
    
    nPixels = args.pixels
    box = args.box_side_length
    grid = args.grid_size
    pixelSize = args.pixel_size
    magnification = args.magnification

    
    gridSize = grid/1000
    
    
    effP = pixelSize/magnification
    
    nBit = int((nPixels - 2 * box)*effP/gridSize)
    
    return _randomFluorListComp(N,nBit,box,effP,gridSize,randData)
    
        
    
    
@numba.jit(nopython=True)  
def _randomFluorListComp(N,nBit,box,effP,gridSize,randData): 
    nnBit = nBit**2
    selectedBits = [-1.0]
    fluorList = np.zeros((N,4),)
#@@@ these are interesting constants.  Are these based on the type of flourescent markers we have? Isn't this going to be impacted by integrationLength?
#@@@ should these be entered as arguments?
#@@@ for 3d name, do we need seperate numbers for these for each marker based on distance to quencher?
    photonsPerFluor = 9000
    photonCountStdev = 1750
    
    wavelength = 730
    
    
    for id in range(N):
        randBit = int(nnBit*np.random.sample())
        while randBit in selectedBits or readBit(randData,randBit) == 0:
            randBit = int(nnBit*np.random.sample())
        
        x = box*effP + int(randBit/nBit)*gridSize
        y = box*effP + int(randBit%nBit)*gridSize

        fluorList[id,0] = x
        fluorList[id,1] = y
#@@@ is wavelength the same for all of these?
        fluorList[id,2] = wavelength
        fluorList[id,3] = np.random.normal(photonsPerFluor,photonCountStdev)
        #fluorList[id,3] = np.random.poisson(photonsPerFluor,photonCountStdev)
        #fluorList[id,0:4] = np.array([x,y,wavelength,np.random.poisson(photonsPerFluor,photonCountStdev)]).T
        
    return fluorList

# Create Random Movie list from randdata.bin seed
def randomMovieList(args):
    # Read from the arguments
    N = args.N
    nPixels = args.pixels
    box = args.box_side_length #@@@ what is this for?
    frames = args.frames
    frameLength = args.integration_time #
    averageDuration = args.on_time
    grid = args.grid_size
    
    frameBuffer = 10
    totalN = int(N*(float(frameLength)/averageDuration)*(frames+2*frameBuffer))
    fluorLists = []
    photonsPerFluor = 25000
    photonCountStdev = 7000
    
    pixelSize = args.pixel_size
    magnification = args.magnification
    
    effP = pixelSize/magnification # @@@ effP might mean "effective pixels"
    
    fluorCounts = [0 for i in range(frames)]
    
    
    
    #nPixels = 512    
    gridSize = grid/1000
    nBit = int((nPixels - 2 * box)*effP/gridSize)
    nnBit = nBit**2
    
    with open('randdata.bin','rb') as fup:
        randData = fup.read(int(nnBit/8)+1)
        
    print("Generating full localization list")
    fullList = randomFluorList(totalN,randData,args)
    print("Full list complete, generating frame lists")
    
    timeStart = np.zeros((fullList.shape[0],),)
    duration = np.zeros((fullList.shape[0],),)
    timeEnd = np.zeros((fullList.shape[0],),)
    nPhotons = np.zeros((fullList.shape[0],),)
    
    for idx,item in enumerate(fullList):
        timeStart[idx] = np.random.sample()*(frames+2*frameBuffer)*frameLength - frameBuffer*frameLength
        duration[idx] = np.random.poisson(averageDuration)
        timeEnd[idx] = timeStart[idx] + duration[idx]
        nPhotons[idx] = np.random.normal(photonsPerFluor,photonCountStdev)*duration[idx]/averageDuration
        for frameId in range(int(timeStart[idx]/frameLength),int(timeEnd[idx]/frameLength)):
            if frameId>=0 and frameId < frames and nPhotons[idx] > 0:
                onTime = min((frameId+1)*frameLength,timeEnd[idx])-max(frameId*frameLength,timeStart[idx])
                if onTime > 0:
                    fluorCounts[frameId]+=1
     
    fluorLists = []               
    for frameId in range(frames):
        fluorLists.append(np.zeros((fluorCounts[frameId],4),))
        
    frameIdx = [0 for i in range(frames)]
                        
    for idx,item in enumerate(fullList):

        for frameId in range(int(timeStart[idx]/frameLength),int(timeEnd[idx]/frameLength)):
            if frameId>=0 and frameId < frames and nPhotons[idx] > 0:
                onTime = min((frameId+1)*frameLength,timeEnd[idx])-max(frameId*frameLength,timeStart[idx])
                if onTime > 0:
                    fup = np.random.poisson(nPhotons[idx]*(onTime/duration[idx]))
                    framePhotons = max(0,fup)    
                    fluorLists[frameId][frameIdx[frameId],:] = np.array([item[0],item[1],item[2],framePhotons])
                    frameIdx[frameId] += 1
                    
    print("frame lists complete")
    return fluorLists

def simulatePaintImage(fluorList,args):
    background = args.background
    nPixels = args.pixels
    nXPixels = nPixels
    nYPixels = nPixels
    
    pixelSize = args.pixel_size
    magnification = args.magnification
    #photonsPerFluor = 9000
    #photonCountStdev = 1750
    
    readNoise = args.read_noise
    bias = args.baseline
    gain = args.gain
    
    NA = 1.33
    
    
    
    x = np.array([i for i in range(nXPixels)])
    x = x.reshape((1,len(x)))
    y = np.array([i for i in range(nYPixels)])
    y = y.reshape((len(y),1))
    
    x = np.kron(pixelSize*x,np.ones((nYPixels,1)))
    y = np.kron(np.ones((1,nXPixels)),pixelSize*y)
    
    #image = np.zeros((nXPixels,nYPixels))
    effP = pixelSize/magnification
    
    
    #sq2sigma = math.sqrt(2)*sigma;
    
    print("<-------------->")
    print("<-------------->")
    print(np.array(fluorList))
    image = _simulatePaintImageComp(nPixels,NA,effP, np.array(fluorList))
    print("<-------------->")
        
    image = image + background    
    #image = np.random.poisson(image)/gain+bias+np.random.normal(0,readNoise,image.shape)
    
    image = _simulateImageNoiseComp(nPixels,image,gain,bias,readNoise)       
    return image.T

@numba.jit(nopython=True)
def _simulatePaintImageComp(nPixels,NA,effP,fluorList):
    nXPixels = nPixels
    nYPixels = nPixels
    print("<-------here------->")
    print(fluorList)
#@@@ why is sigma 
    sigma = 0.45*fluorList[:,2]/1000/2/NA/effP
    print("<-------------->")
    sq2sigma = math.sqrt(2)*sigma
    print("<-------------->")
    
    image = np.zeros((nXPixels,nYPixels))


#@@@ For each flourescent marker
    for idx in range(fluorList.shape[0]):
        #sigma = 0.45*fluor[2]/1000/2/NA/effP
        #sq2sigma = math.sqrt(2)*sigma;
#@@@ I get the x,y coordinates, width
#@@@ sigma stores something based on wavelength of each fluor in the fluorList
#@@@ currently it looks like wavelength is hard-coded to be the same for all fluors
#@@@ fluorList[:,2] stores the wavelength for each fluor, but it is all the same values
#@@@ so  sigma = 0.45*fluorList[:,2]/1000/2/NA/effP will store all the same values
#@@@ why 5*sigma[idx])?
        w = int(round(5*sigma[idx]))
        x0 = int(math.floor(fluorList[idx,0]/effP))
        y0 = int(math.floor(fluorList[idx,1]/effP))
# @@@ might be bad to bound xl,xu,yl,yu at edge like we're doing below - I think this will mess with the distribution of photons for flourophores at the edge of the image frame.
        xl = max(0,x0-w) 
        xu = min(nXPixels-1,x0+w)
        yl = max(0,y0-w)
        yu = min(nYPixels-1,y0+w)
       
# @@@ Why are we setting NPhot outside the loop? This means it is constant for the entire loop?
# @@@ fluorList[idx,3] is set to a random number: fluorList[id,3] = np.random.normal(photonsPerFluor,photonCountStdev)
# @@@ maybe have an NPhot2, NPhot3, ... for each vertical flourphore/marker
        NPhot = np.random.normal(fluorList[idx,3])
        
        if xl<=xu and yl<=yu:
            for xi in range(xl,xu):
                xp = xi  - fluorList[idx,0]/effP
                for yi in range(yl,yu):
                    yp = yi  - fluorList[idx,1]/effP
                    #xp = x[yl:yu,xl:xu] - fluor[0]*magnification
                    #yp = y[yl:yu,xl:xu] - fluor[1]*magnification
                    #r2 = xp**2 + yp**2
                    #image[yl:yu,xl:xu] += photonsPerFluor*np.exp(-r2/2/sigma**2)/2/math.pi/sigma
#@@@ maybe this is the main line where you have to change this for 3dnam, basically you have this line repeated for each vertical axis flourophore/marker
                    image[yi,xi] = image[yi,xi] + NPhot/4*(np.math.erf((xp+.5)/sq2sigma[idx])-np.math.erf((xp-.5)/sq2sigma[idx]))*(np.math.erf((yp+.5)/sq2sigma[idx])-np.math.erf((yp-0.5)/sq2sigma[idx]))
                    
    return image

@numba.jit(nopython=True)
def _simulateImageNoiseComp(nPixels, image,gain,bias,readNoise):
    maxInt = 2**16-1
    nXPixels = nPixels
    nYPixels = nPixels
    
    for xi in range(nXPixels):
        for yi in range(nYPixels):
            image[xi,yi] = np.random.poisson(image[xi,yi])/gain + bias + np.random.normal(0,readNoise)
            image[xi,yi] = min(maxInt,image[xi,yi])
            
    return image

# @@@ Need will to tell us all about each of these arguments
if __name__ == '__main__':       
    # parsing the arguments
    testsim_parser = argparse.ArgumentParser(description="PAINT random image simulation script")
    
    testsim_parser.add_argument(
        "-b", "--box-side-length", type=int, default=3, help="box side length"
    )
    testsim_parser.add_argument(
        "-g", "--gradient", type=int, default=5000, help="minimum net gradient"
    )
    testsim_parser.add_argument(
        "-bl", "--baseline", type=int, default=700, help="camera baseline"
    )
    testsim_parser.add_argument(
        "-s", "--sensitivity", type=float, default=1, help="camera sensitivity"
    )
    # number of the photons per photo electronics
    testsim_parser.add_argument(
        "-ga", "--gain", type=float, default=1/31, help="camera gain"
    )
    #testsim_parser.add_argument(
    #    "-qe", "--qe", type=float, default=1, help="camera quantum efficiency"
    #)
    # NUmber of average of fluorophores
    testsim_parser.add_argument(
        "-N", "--N", type=int, default=50, help="number of fluorophores to simulate per frame"        
    )
    # Constant number of fluorophore 
    # @@@ is above comment correct? Seems like this is just background noise - the amount
    # @@@ we generate.  But if so why is it a constant number?  Seems like it ought to have
    # @@@ a gausian distribution around some value.
    testsim_parser.add_argument(
        "-bg", "--background", type=int, default=45, help="background photons"        
    )
    testsim_parser.add_argument(
        "-fr", "--frames", type=int, default=10, help="simulated frames"        
    )
    # The duration of frame (how much each lasts)
    testsim_parser.add_argument(
        "-it", "--integration-time", type=float, default=300, help="integration time (ms)"        
    )
    # array size
    testsim_parser.add_argument(
        "-gs", "--grid-size", type=float, default=5, help="grid size (nm)"        
    )
    testsim_parser.add_argument(
        "-px", "--pixels", type=int, default = 512, help="Size of camera (number of pixels on each edge)"    
    )
    # 
    testsim_parser.add_argument(
        "-ot", "--on-time", type=float, default = 1270, help="Mean on time of blinking event"    
    )
    # Size of sensor pixels
    testsim_parser.add_argument(
        "-ps", "--pixel-size", type=float, default = 16, help="Size of physical imager pixel, in microns"    
    )
    testsim_parser.add_argument(
        "-m", "--magnification", type=float, default = 150, help="Total system magnification"    
    )
    testsim_parser.add_argument(
        "-rn", "--read_noise", type=float, default = 20, help="Imager readnoise (electrons)"    
    )
    testsim_parser.add_argument(
        "-x", "--xml", help="XML config file for 3d-daostorm analyis (default = default_config.xml)",default="default_config.xml"
    )
    args = testsim_parser.parse_args()
    
    _testsim(args)
